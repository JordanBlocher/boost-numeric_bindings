[/ 

THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DO NOT EDIT!

]

[section tgsyl]

[heading Prototype]
There is one prototype of `tgsyl` available, please see below.
``
tgsyl( const int_t ijob, const MatrixA& a, const MatrixB& b,
        MatrixC& c, const MatrixD& d, const MatrixE& e, MatrixF& f, Scalar >,
        Scalar > );
``


[heading Description]

`tgsyl` (short for $FRIENDLY_NAME) provides a C++
interface to LAPACK routines STGSYL, DTGSYL, CTGSYL, and ZTGSYL. 
`tgsyl` solves the generalized Sylvester equation:

A * R - L * B = scale * C  (1)
D * R - L * E = scale * F

where R and L are unknown m-by-n matrices, (A, D), (B, E) and
(C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
respectively, with complex entries. A, B, D and E are upper
triangular (i.e., (A,D) and (B,E) in generalized Schur form).

The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
is an output scaling factor chosen to avoid overflow.

In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
is defined as

Z = [ kron(In, A) -kron(B', Im) ] (2)
[ kron(In, D) -kron(E', Im) ],

Here Ix is the identity matrix of size x and X' is the conjugate
transpose of X. Kron(X, Y) is the Kronecker product between the
matrices X and Y.

If TRANS = 'C', y in the conjugate transposed system Z'*y = scale*b
is solved for, which is equivalent to solve for R and L in

A' * R + D' * L = scale * C  (3)
R * B' + L * E' = scale * -F

This case (TRANS = 'C') is used to compute an one-norm-based estimate
of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
and (B,E), using ZLACON.

If IJOB >= 1, `tgsyl` computes a Frobenius norm-based estimate of
Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
reciprocal of the smallest singular value of Z.

This is a level-3 BLAS algorithm.

The selection of the LAPACK routine is done during compile-time, 
and is determined by the type of values contained in type `MatrixA`.
The type of values is obtained through the `value_type` meta-function
 `typename value_type<MatrixA>::type`.
The dispatching table below illustrates to which specific routine 
the code path will be generated. 

[table Dispatching of tgsyl
[  [ Value type of MatrixA ] [LAPACK routine] ]
[  [`float`][STGSYL] ]
[  [`double`][DTGSYL] ]
[  [`complex<float>`][CTGSYL] ]
[  [`complex<double>`][ZTGSYL] ]

]


[heading Definition]
Defined in header [headerref boost/numeric/bindings/lapack/computational/tgsyl.hpp].


[heading Parameters or Requirements on Types]

[variablelist Parameters
    [[MatrixA] [The definition of term 1]]
    [[MatrixB] [The definition of term 2]]
    [[MatrixC] [
    The definition of term 3.

    Definitions may contain paragraphs.
    ]]
]


[heading Complexity]


[heading Example]
``
#include <boost/numeric/bindings/lapack/computational/tgsyl.hpp>
using namespace boost::numeric::bindings;

lapack::tgsyl( x, y, z );

``

this will output

``
[5] 0 1 2 3 4 5
``



[heading Notes]


[heading See Also]

* Originating Fortran source files [@http://www.netlib.org/lapack/single/stgsyl.f stgsyl.f], [@http://www.netlib.org/lapack/double/dtgsyl.f dtgsyl.f], [@http://www.netlib.org/lapack/complex/ctgsyl.f ctgsyl.f], and [@http://www.netlib.org/lapack/complex16/ztgsyl.f ztgsyl.f] at Netlib.

[endsect]
