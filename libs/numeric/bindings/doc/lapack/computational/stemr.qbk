[/ 

THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DO NOT EDIT!

]

[section stemr]

[heading Prototype]
There is one prototype of `stemr` available, please see below.
``
stemr( const char jobz, const char range, const int_t n,
        VectorD& d, VectorE& e, const Scalar >, const Scalar >,
        const int_t il, const int_t iu,
        int_t& m, VectorW& w, MatrixZ& z,
        const int_t nzc, VectorISUPPZ& isuppz,
        fortran_bool_t& tryrac );
``


[heading Description]

`stemr` (short for $FRIENDLY_NAME) provides a C++
interface to LAPACK routines SSTEMR, DSTEMR, CSTEMR, and ZSTEMR. 
`stemr` computes selected eigenvalues and, optionally, eigenvectors
of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
a well defined set of pairwise different real eigenvalues, the corresponding
real eigenvectors are pairwise orthogonal.

The spectrum may be computed either completely or partially by specifying
either an interval (VL,VU] or a range of indices IL:IU for the desired
eigenvalues.

Depending on the number of desired eigenvalues, these are computed either
by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
computed by the use of various suitable L D L^T factorizations near clusters
of close eigenvalues (referred to as RRRs, Relatively Robust
Representations). An informal sketch of the algorithm follows.

For each unreduced block (submatrix) of T,
(a) Compute T - sigma I = L D L^T, so that L and D
define all the wanted eigenvalues to high relative accuracy.
This means that small relative changes in the entries of D and L
cause only small relative changes in the eigenvalues and
eigenvectors. The standard (unfactored) representation of the
tridiagonal matrix T does not have this property in general.
(b) Compute the eigenvalues to suitable accuracy.
If the eigenvectors are desired, the algorithm attains full
accuracy of the computed eigenvalues only right before
the corresponding vectors have to be computed, see steps c) and d).
(c) For each cluster of close eigenvalues, select a new
shift close to the cluster, find a new factorization, and refine
the shifted eigenvalues to suitable accuracy.
(d) For each eigenvalue with a large enough relative separation compute
the corresponding eigenvector by forming a rank revealing twisted
factorization. Go back to (c) for any clusters that remain.

For more details, see:
- Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
- Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
2004. Also LAPACK Working Note 154.
- Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
tridiagonal eigenvalue/eigenvector problem",
Computer Science Division Technical Report No. UCB/CSD-97-971,
UC Berkeley, May 1997.

Further Details
1.`stemr` works only on machines which follow IEEE-754
floating-point standard in their handling of infinities and NaNs.
This permits the use of efficient inner loops avoiding a check for
zero divisors.

2. LAPACK routines can be used to reduce a complex Hermitean matrix to
real symmetric tridiagonal form.

(Any complex Hermitean tridiagonal matrix has real values on its diagonal
and potentially complex numbers on its off-diagonals. By applying a
similarity transform with an appropriate diagonal matrix
diag(1,e^{i \phy_1}, ... , e^{i \phy_{n-1}}), the complex Hermitean
matrix can be transformed into a real symmetric matrix and complex
arithmetic can be entirely avoided.)

While the eigenvectors of the real symmetric tridiagonal matrix are real,
the eigenvectors of original complex Hermitean matrix have complex entries
in general.
Since LAPACK drivers overwrite the matrix data with the eigenvectors,
`stemr` accepts complex workspace to facilitate interoperability
with ZUNMTR or ZUPMTR.

The selection of the LAPACK routine is done during compile-time, 
and is determined by the type of values contained in type `VectorD`.
The type of values is obtained through the `value_type` meta-function
 `typename value_type<VectorD>::type`.
The dispatching table below illustrates to which specific routine 
the code path will be generated. 

[table Dispatching of stemr
[  [ Value type of VectorD ] [LAPACK routine] ]
[  [`float`][SSTEMR] ]
[  [`double`][DSTEMR] ]
[  [`complex<float>`][CSTEMR] ]
[  [`complex<double>`][ZSTEMR] ]

]


[heading Definition]
Defined in header [headerref boost/numeric/bindings/lapack/computational/stemr.hpp].


[heading Parameters or Requirements on Types]

[variablelist Parameters
    [[MatrixA] [The definition of term 1]]
    [[MatrixB] [The definition of term 2]]
    [[MatrixC] [
    The definition of term 3.

    Definitions may contain paragraphs.
    ]]
]


[heading Complexity]


[heading Example]
``
#include <boost/numeric/bindings/lapack/computational/stemr.hpp>
using namespace boost::numeric::bindings;

lapack::stemr( x, y, z );

``

this will output

``
[5] 0 1 2 3 4 5
``



[heading Notes]


[heading See Also]

* Originating Fortran source files [@http://www.netlib.org/lapack/single/sstemr.f sstemr.f], [@http://www.netlib.org/lapack/double/dstemr.f dstemr.f], [@http://www.netlib.org/lapack/complex/cstemr.f cstemr.f], and [@http://www.netlib.org/lapack/complex16/zstemr.f zstemr.f] at Netlib.

[endsect]
