[/ 

THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DO NOT EDIT!

]

[section tgsja]

[heading Prototype]
There is one prototype of `tgsja` available, please see below.
``
tgsja( const char jobu, const char jobv, const char jobq,
        const int_t k, const int_t l, MatrixA& a,
        MatrixB& b, const Scalar >, const Scalar >, VectorALPHA& alpha,
        VectorBETA& beta, MatrixU& u, MatrixV& v, MatrixQ& q,
        int_t& ncycle );
``


[heading Description]

`tgsja` (short for $FRIENDLY_NAME) provides a C++
interface to LAPACK routines STGSJA, DTGSJA, CTGSJA, and ZTGSJA. 
`tgsja` computes the generalized singular value decomposition (GSVD)
of two complex upper triangular (or trapezoidal) matrices A and B.

On entry, it is assumed that matrices A and B have the following
forms, which may be obtained by the preprocessing subroutine ZGGSVP
from a general M-by-N matrix A and P-by-N matrix B:

N-K-L K L
A = K ( 0 A12 A13 ) if M-K-L >= 0;
L ( 0 0 A23 )
M-K-L ( 0 0 0 )

N-K-L K L
A = K ( 0 A12 A13 ) if M-K-L < 0;
M-K ( 0 0 A23 )

N-K-L K L
B = L ( 0 0 B13 )
P-L ( 0 0 0 )

where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
otherwise A23 is (M-K)-by-L upper trapezoidal.

On exit,

U'*A*Q = D1*( 0 R ), V'*B*Q = D2*( 0 R ),

where U, V and Q are unitary matrices, Z' denotes the conjugate
transpose of Z, R is a nonsingular upper triangular matrix, and D1
and D2 are ``diagonal'' matrices, which are of the following
structures:

If M-K-L >= 0,

K L
D1 = K ( I 0 )
L ( 0 C )
M-K-L ( 0 0 )

K L
D2 = L ( 0 S )
P-L ( 0 0 )

N-K-L K L
( 0 R ) = K ( 0 R11 R12 ) K
L ( 0 0 R22 ) L

where

C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
S = diag( BETA(K+1), ... , BETA(K+L) ),
C**2 + S**2 = I.

R is stored in A(1:K+L,N-K-L+1:N) on exit.

If M-K-L < 0,

K M-K K+L-M
D1 = K ( I 0 0 )
M-K ( 0 C 0 )

K M-K K+L-M
D2 = M-K ( 0 S 0 )
K+L-M ( 0 0 I )
P-L ( 0 0 0 )

N-K-L K M-K K+L-M
( 0 R ) = K ( 0 R11 R12 R13 )
M-K ( 0 0 R22 R23 )
K+L-M ( 0 0 0 R33 )

where
C = diag( ALPHA(K+1), ... , ALPHA(M) ),
S = diag( BETA(K+1), ... , BETA(M) ),
C**2 + S**2 = I.

R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
( 0 R22 R23 )
in B(M-K+1:L,N+M-K-L+1:N) on exit.

The computation of the unitary transformation matrices U, V or Q
is optional. These matrices may either be formed explicitly, or they
may be postmultiplied into input matrices U1, V1, or Q1.

The selection of the LAPACK routine is done during compile-time, 
and is determined by the type of values contained in type `MatrixA`.
The type of values is obtained through the `value_type` meta-function
 `typename value_type<MatrixA>::type`.
The dispatching table below illustrates to which specific routine 
the code path will be generated. 

[table Dispatching of tgsja
[  [ Value type of MatrixA ] [LAPACK routine] ]
[  [`float`][STGSJA] ]
[  [`double`][DTGSJA] ]
[  [`complex<float>`][CTGSJA] ]
[  [`complex<double>`][ZTGSJA] ]

]


[heading Definition]
Defined in header [headerref boost/numeric/bindings/lapack/computational/tgsja.hpp].


[heading Parameters or Requirements on Types]

[variablelist Parameters
    [[MatrixA] [The definition of term 1]]
    [[MatrixB] [The definition of term 2]]
    [[MatrixC] [
    The definition of term 3.

    Definitions may contain paragraphs.
    ]]
]


[heading Complexity]


[heading Example]
``
#include <boost/numeric/bindings/lapack/computational/tgsja.hpp>
using namespace boost::numeric::bindings;

lapack::tgsja( x, y, z );

``

this will output

``
[5] 0 1 2 3 4 5
``



[heading Notes]


[heading See Also]

* Originating Fortran source files [@http://www.netlib.org/lapack/single/stgsja.f stgsja.f], [@http://www.netlib.org/lapack/double/dtgsja.f dtgsja.f], [@http://www.netlib.org/lapack/complex/ctgsja.f ctgsja.f], and [@http://www.netlib.org/lapack/complex16/ztgsja.f ztgsja.f] at Netlib.

[endsect]
