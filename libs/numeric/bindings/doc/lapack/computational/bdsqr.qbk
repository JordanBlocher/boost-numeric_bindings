[/ 

THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DO NOT EDIT!

]

[section bdsqr]

[heading Prototype]
There is one prototype of `bdsqr` available, please see below.
``
bdsqr( const char uplo, const int_t n, VectorD& d,
        VectorE& e, MatrixVT& vt, MatrixU& u, MatrixC& c );
``


[heading Description]

`bdsqr` (short for $FRIENDLY_NAME) provides a C++
interface to LAPACK routines SBDSQR, DBDSQR, CBDSQR, and ZBDSQR. 
`bdsqr` computes the singular values and, optionally, the right and/or
left singular vectors from the singular value decomposition (SVD) of
a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
zero-shift QR algorithm. The SVD of B has the form

B = Q * S * P**H

where S is the diagonal matrix of singular values, Q is an orthogonal
matrix of left singular vectors, and P is an orthogonal matrix of
right singular vectors. If left singular vectors are requested, this
subroutine actually returns U*Q instead of Q, and, if right singular
vectors are requested, this subroutine returns P**H*VT instead of
P**H, for given complex input matrices U and VT. When U and VT are
the unitary matrices that reduce a general matrix A to bidiagonal
form: A = U*B*VT, as computed by ZGEBRD, then

A = (U*Q) * S * (P**H*VT)

is the SVD of A. Optionally, the subroutine may also compute Q**H*C
for a given complex input matrix C.

See "Computing Small Singular Values of Bidiagonal Matrices With
Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
no. 5, pp. 873-912, Sept 1990) and
"Accurate singular values and differential qd algorithms," by
B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
Department, University of California at Berkeley, July 1992
for a detailed description of the algorithm.

The selection of the LAPACK routine is done during compile-time, 
and is determined by the type of values contained in type `VectorD`.
The type of values is obtained through the `value_type` meta-function
 `typename value_type<VectorD>::type`.
The dispatching table below illustrates to which specific routine 
the code path will be generated. 

[table Dispatching of bdsqr
[  [ Value type of VectorD ] [LAPACK routine] ]
[  [`float`][SBDSQR] ]
[  [`double`][DBDSQR] ]
[  [`complex<float>`][CBDSQR] ]
[  [`complex<double>`][ZBDSQR] ]

]


[heading Definition]
Defined in header [headerref boost/numeric/bindings/lapack/computational/bdsqr.hpp].


[heading Parameters or Requirements on Types]

[variablelist Parameters
    [[MatrixA] [The definition of term 1]]
    [[MatrixB] [The definition of term 2]]
    [[MatrixC] [
    The definition of term 3.

    Definitions may contain paragraphs.
    ]]
]


[heading Complexity]


[heading Example]
``
#include <boost/numeric/bindings/lapack/computational/bdsqr.hpp>
using namespace boost::numeric::bindings;

lapack::bdsqr( x, y, z );

``

this will output

``
[5] 0 1 2 3 4 5
``



[heading Notes]


[heading See Also]

* Originating Fortran source files [@http://www.netlib.org/lapack/single/sbdsqr.f sbdsqr.f], [@http://www.netlib.org/lapack/double/dbdsqr.f dbdsqr.f], [@http://www.netlib.org/lapack/complex/cbdsqr.f cbdsqr.f], and [@http://www.netlib.org/lapack/complex16/zbdsqr.f zbdsqr.f] at Netlib.

[endsect]
