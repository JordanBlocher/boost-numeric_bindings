[/ 

THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DO NOT EDIT!

]

[section geevx]

[heading Prototype]
There are two prototypes of `geevx` available, please see below.
``
geevx( const char balanc, const char jobvl, const char jobvr,
        const char sense, MatrixA& a, VectorWR& wr, VectorWI& wi,
        MatrixVL& vl, MatrixVR& vr, int_t& ilo,
        int_t& ihi, VectorSCALE& scale, Scalar >,
        VectorRCONDE& rconde, VectorRCONDV& rcondv );
``

``
geevx( const char balanc, const char jobvl, const char jobvr,
        const char sense, MatrixA& a, VectorW& w, MatrixVL& vl, MatrixVR& vr,
        int_t& ilo, int_t& ihi, VectorSCALE& scale,
        Scalar >, VectorRCONDE& rconde, VectorRCONDV& rcondv );
``


[heading Description]

`geevx` (short for $FRIENDLY_NAME) provides a C++
interface to LAPACK routines SGEEVX, DGEEVX, CGEEVX, and ZGEEVX. 
`geevx` computes for an N-by-N complex nonsymmetric matrix A, the
eigenvalues and, optionally, the left and/or right eigenvectors.

Optionally also, it computes a balancing transformation to improve
the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
(RCONDE), and reciprocal condition numbers for the right
eigenvectors (RCONDV).

The right eigenvector v(j) of A satisfies
A * v(j) = lambda(j) * v(j)
where lambda(j) is its eigenvalue.
The left eigenvector u(j) of A satisfies
u(j)**H * A = lambda(j) * u(j)**H
where u(j)**H denotes the conjugate transpose of u(j).

The computed eigenvectors are normalized to have Euclidean norm
equal to 1 and largest component real.

Balancing a matrix means permuting the rows and columns to make it
more nearly upper triangular, and applying a diagonal similarity
transformation D * A * D**(-1), where D is a diagonal matrix, to
make its rows and columns closer in norm and the condition numbers
of its eigenvalues and eigenvectors smaller. The computed
reciprocal condition numbers correspond to the balanced matrix.
Permuting rows and columns will not change the condition numbers
(in exact arithmetic) but diagonal scaling will. For further
explanation of balancing, see section 4.10.2 of the LAPACK
Users' Guide.

The selection of the LAPACK routine is done during compile-time, 
and is determined by the type of values contained in type `MatrixA`.
The type of values is obtained through the `value_type` meta-function
 `typename value_type<MatrixA>::type`.
The dispatching table below illustrates to which specific routine 
the code path will be generated. 

[table Dispatching of geevx
[  [ Value type of MatrixA ] [LAPACK routine] ]
[  [`float`][SGEEVX] ]
[  [`double`][DGEEVX] ]
[  [`complex<float>`][CGEEVX] ]
[  [`complex<double>`][ZGEEVX] ]

]


[heading Definition]
Defined in header [headerref boost/numeric/bindings/lapack/driver/geevx.hpp].


[heading Parameters or Requirements on Types]

[variablelist Parameters
    [[MatrixA] [The definition of term 1]]
    [[MatrixB] [The definition of term 2]]
    [[MatrixC] [
    The definition of term 3.

    Definitions may contain paragraphs.
    ]]
]


[heading Complexity]


[heading Example]
``
#include <boost/numeric/bindings/lapack/driver/geevx.hpp>
using namespace boost::numeric::bindings;

lapack::geevx( x, y, z );

``

this will output

``
[5] 0 1 2 3 4 5
``



[heading Notes]


[heading See Also]

* Originating Fortran source files [@http://www.netlib.org/lapack/single/sgeevx.f sgeevx.f], [@http://www.netlib.org/lapack/double/dgeevx.f dgeevx.f], [@http://www.netlib.org/lapack/complex/cgeevx.f cgeevx.f], and [@http://www.netlib.org/lapack/complex16/zgeevx.f zgeevx.f] at Netlib.

[endsect]
