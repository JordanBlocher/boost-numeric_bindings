[/ 

THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DO NOT EDIT!

]

[section ppsvx]

[heading Prototype]
There is one prototype of `ppsvx` available, please see below.
``
ppsvx( const char fact, MatrixAP& ap, VectorAFP& afp, char& equed,
        VectorS& s, MatrixB& b, MatrixX& x, Scalar >, VectorFERR& ferr,
        VectorBERR& berr );
``


[heading Description]

`ppsvx` (short for $FRIENDLY_NAME) provides a C++
interface to LAPACK routines SPPSVX, DPPSVX, CPPSVX, and ZPPSVX. 
`ppsvx` uses the Cholesky factorization A = U**H*U or A = L*L**H to
compute the solution to a complex system of linear equations
A * X = B,
where A is an N-by-N Hermitian positive definite matrix stored in
packed format and X and B are N-by-NRHS matrices.

Error bounds on the solution and a condition estimate are also
provided.

Description
===========

The following steps are performed:

1. If FACT = 'E', real scaling factors are computed to equilibrate
the system:
diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
Whether or not the system will be equilibrated depends on the
scaling of the matrix A, but if equilibration is used, A is
overwritten by diag(S)*A*diag(S) and B by diag(S)*B.

2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
factor the matrix A (after equilibration if FACT = 'E') as
A = U'* U , if UPLO = 'U', or
A = L * L', if UPLO = 'L',
where U is an upper triangular matrix, L is a lower triangular
matrix, and ' indicates conjugate transpose.

3. If the leading i-by-i principal minor is not positive definite,
then the routine returns with INFO = i. Otherwise, the factored
form of A is used to estimate the condition number of the matrix
A. If the reciprocal of the condition number is less than machine
precision, INFO = N+1 is returned as a warning, but the routine
still goes on to solve for X and compute error bounds as
described below.

4. The system of equations is solved for X using the factored form
of A.

5. Iterative refinement is applied to improve the computed solution
matrix and calculate error bounds and backward error estimates
for it.

6. If equilibration was used, the matrix X is premultiplied by
diag(S) so that it solves the original system before
equilibration.

The selection of the LAPACK routine is done during compile-time, 
and is determined by the type of values contained in type `MatrixAP`.
The type of values is obtained through the `value_type` meta-function
 `typename value_type<MatrixAP>::type`.
The dispatching table below illustrates to which specific routine 
the code path will be generated. 

[table Dispatching of ppsvx
[  [ Value type of MatrixAP ] [LAPACK routine] ]
[  [`float`][SPPSVX] ]
[  [`double`][DPPSVX] ]
[  [`complex<float>`][CPPSVX] ]
[  [`complex<double>`][ZPPSVX] ]

]


[heading Definition]
Defined in header [headerref boost/numeric/bindings/lapack/driver/ppsvx.hpp].


[heading Parameters or Requirements on Types]

[variablelist Parameters
    [[MatrixA] [The definition of term 1]]
    [[MatrixB] [The definition of term 2]]
    [[MatrixC] [
    The definition of term 3.

    Definitions may contain paragraphs.
    ]]
]


[heading Complexity]


[heading Example]
``
#include <boost/numeric/bindings/lapack/driver/ppsvx.hpp>
using namespace boost::numeric::bindings;

lapack::ppsvx( x, y, z );

``

this will output

``
[5] 0 1 2 3 4 5
``



[heading Notes]


[heading See Also]

* Originating Fortran source files [@http://www.netlib.org/lapack/single/sppsvx.f sppsvx.f], [@http://www.netlib.org/lapack/double/dppsvx.f dppsvx.f], [@http://www.netlib.org/lapack/complex/cppsvx.f cppsvx.f], and [@http://www.netlib.org/lapack/complex16/zppsvx.f zppsvx.f] at Netlib.

[endsect]
