[/ 

THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DO NOT EDIT!

]

[section ggevx]

[heading Prototype]
There are two prototypes of `ggevx` available, please see below.
``
ggevx( const char balanc, const char jobvl, const char jobvr,
        const char sense, MatrixA& a, MatrixB& b, VectorALPHAR& alphar,
        VectorALPHAI& alphai, VectorBETA& beta, MatrixVL& vl, MatrixVR& vr,
        int_t& ilo, int_t& ihi, VectorLSCALE& lscale,
        VectorRSCALE& rscale, Scalar >, Scalar >, VectorRCONDE& rconde,
        VectorRCONDV& rcondv );
``

``
ggevx( const char balanc, const char jobvl, const char jobvr,
        const char sense, MatrixA& a, MatrixB& b, VectorALPHA& alpha,
        VectorBETA& beta, MatrixVL& vl, MatrixVR& vr, int_t& ilo,
        int_t& ihi, VectorLSCALE& lscale, VectorRSCALE& rscale,
        Scalar >, Scalar >, VectorRCONDE& rconde, VectorRCONDV& rcondv );
``


[heading Description]

`ggevx` (short for $FRIENDLY_NAME) provides a C++
interface to LAPACK routines SGGEVX, DGGEVX, CGGEVX, and ZGGEVX. 
`ggevx` computes for a pair of N-by-N complex nonsymmetric matrices
(A,B) the generalized eigenvalues, and optionally, the left and/or
right generalized eigenvectors.

Optionally, it also computes a balancing transformation to improve
the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
the eigenvalues (RCONDE), and reciprocal condition numbers for the
right eigenvectors (RCONDV).

A generalized eigenvalue for a pair of matrices (A,B) is a scalar
lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
singular. It is usually represented as the pair (alpha,beta), as
there is a reasonable interpretation for beta=0, and even for both
being zero.

The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
of (A,B) satisfies
A * v(j) = lambda(j) * B * v(j) .
The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
of (A,B) satisfies
u(j)**H * A = lambda(j) * u(j)**H * B.
where u(j)**H is the conjugate-transpose of u(j).

The selection of the LAPACK routine is done during compile-time, 
and is determined by the type of values contained in type `MatrixA`.
The type of values is obtained through the `value_type` meta-function
 `typename value_type<MatrixA>::type`.
The dispatching table below illustrates to which specific routine 
the code path will be generated. 

[table Dispatching of ggevx
[  [ Value type of MatrixA ] [LAPACK routine] ]
[  [`float`][SGGEVX] ]
[  [`double`][DGGEVX] ]
[  [`complex<float>`][CGGEVX] ]
[  [`complex<double>`][ZGGEVX] ]

]


[heading Definition]
Defined in header [headerref boost/numeric/bindings/lapack/driver/ggevx.hpp].


[heading Parameters or Requirements on Types]

[variablelist Parameters
    [[MatrixA] [The definition of term 1]]
    [[MatrixB] [The definition of term 2]]
    [[MatrixC] [
    The definition of term 3.

    Definitions may contain paragraphs.
    ]]
]


[heading Complexity]


[heading Example]
``
#include <boost/numeric/bindings/lapack/driver/ggevx.hpp>
using namespace boost::numeric::bindings;

lapack::ggevx( x, y, z );

``

this will output

``
[5] 0 1 2 3 4 5
``



[heading Notes]


[heading See Also]

* Originating Fortran source files [@http://www.netlib.org/lapack/single/sggevx.f sggevx.f], [@http://www.netlib.org/lapack/double/dggevx.f dggevx.f], [@http://www.netlib.org/lapack/complex/cggevx.f cggevx.f], and [@http://www.netlib.org/lapack/complex16/zggevx.f zggevx.f] at Netlib.

[endsect]
