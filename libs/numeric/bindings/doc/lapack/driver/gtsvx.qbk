[/ 

THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DO NOT EDIT!

]

[section gtsvx]

[heading Prototype]
There is one prototype of `gtsvx` available, please see below.
``
gtsvx( const char fact, const VectorDL& dl, const VectorD& d,
        const VectorDU& du, VectorDLF& dlf, VectorDF& df, VectorDUF& duf,
        VectorDU2& du2, VectorIPIV& ipiv, const MatrixB& b, MatrixX& x,
        Scalar >, VectorFERR& ferr, VectorBERR& berr );
``


[heading Description]

`gtsvx` (short for $FRIENDLY_NAME) provides a C++
interface to LAPACK routines SGTSVX, DGTSVX, CGTSVX, and ZGTSVX. 
`gtsvx` uses the LU factorization to compute the solution to a complex
system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
matrices.

Error bounds on the solution and a condition estimate are also
provided.

Description
===========

The following steps are performed:

1. If FACT = 'N', the LU decomposition is used to factor the matrix A
as A = L * U, where L is a product of permutation and unit lower
bidiagonal matrices and U is upper triangular with nonzeros in
only the main diagonal and first two superdiagonals.

2. If some U(i,i)=0, so that U is exactly singular, then the routine
returns with INFO = i. Otherwise, the factored form of A is used
to estimate the condition number of the matrix A. If the
reciprocal of the condition number is less than machine precision,
INFO = N+1 is returned as a warning, but the routine still goes on
to solve for X and compute error bounds as described below.

3. The system of equations is solved for X using the factored form
of A.

4. Iterative refinement is applied to improve the computed solution
matrix and calculate error bounds and backward error estimates
for it.

The selection of the LAPACK routine is done during compile-time, 
and is determined by the type of values contained in type `VectorDL`.
The type of values is obtained through the `value_type` meta-function
 `typename value_type<VectorDL>::type`.
The dispatching table below illustrates to which specific routine 
the code path will be generated. 

[table Dispatching of gtsvx
[  [ Value type of VectorDL ] [LAPACK routine] ]
[  [`float`][SGTSVX] ]
[  [`double`][DGTSVX] ]
[  [`complex<float>`][CGTSVX] ]
[  [`complex<double>`][ZGTSVX] ]

]


[heading Definition]
Defined in header [headerref boost/numeric/bindings/lapack/driver/gtsvx.hpp].


[heading Parameters or Requirements on Types]

[variablelist Parameters
    [[MatrixA] [The definition of term 1]]
    [[MatrixB] [The definition of term 2]]
    [[MatrixC] [
    The definition of term 3.

    Definitions may contain paragraphs.
    ]]
]


[heading Complexity]


[heading Example]
``
#include <boost/numeric/bindings/lapack/driver/gtsvx.hpp>
using namespace boost::numeric::bindings;

lapack::gtsvx( x, y, z );

``

this will output

``
[5] 0 1 2 3 4 5
``



[heading Notes]


[heading See Also]

* Originating Fortran source files [@http://www.netlib.org/lapack/single/sgtsvx.f sgtsvx.f], [@http://www.netlib.org/lapack/double/dgtsvx.f dgtsvx.f], [@http://www.netlib.org/lapack/complex/cgtsvx.f cgtsvx.f], and [@http://www.netlib.org/lapack/complex16/zgtsvx.f zgtsvx.f] at Netlib.

[endsect]
