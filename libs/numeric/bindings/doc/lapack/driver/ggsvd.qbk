[/ 

THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DO NOT EDIT!

]

[section ggsvd]

[heading Prototype]
There is one prototype of `ggsvd` available, please see below.
``
ggsvd( const char jobu, const char jobv, const char jobq,
        int_t& k, int_t& l, MatrixA& a, MatrixB& b,
        VectorALPHA& alpha, VectorBETA& beta, MatrixU& u, MatrixV& v,
        MatrixQ& q );
``


[heading Description]

`ggsvd` (short for $FRIENDLY_NAME) provides a C++
interface to LAPACK routines SGGSVD, DGGSVD, CGGSVD, and ZGGSVD. 
`ggsvd` computes the generalized singular value decomposition (GSVD)
of an M-by-N complex matrix A and P-by-N complex matrix B:

U'*A*Q = D1*( 0 R ), V'*B*Q = D2*( 0 R )

where U, V and Q are unitary matrices, and Z' means the conjugate
transpose of Z. Let K+L = the effective numerical rank of the
matrix (A',B')', then R is a (K+L)-by-(K+L) nonsingular upper
triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
matrices and of the following structures, respectively:

If M-K-L >= 0,

K L
D1 = K ( I 0 )
L ( 0 C )
M-K-L ( 0 0 )

K L
D2 = L ( 0 S )
P-L ( 0 0 )

N-K-L K L
( 0 R ) = K ( 0 R11 R12 )
L ( 0 0 R22 )
where

C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
S = diag( BETA(K+1), ... , BETA(K+L) ),
C**2 + S**2 = I.

R is stored in A(1:K+L,N-K-L+1:N) on exit.

If M-K-L < 0,

K M-K K+L-M
D1 = K ( I 0 0 )
M-K ( 0 C 0 )

K M-K K+L-M
D2 = M-K ( 0 S 0 )
K+L-M ( 0 0 I )
P-L ( 0 0 0 )

N-K-L K M-K K+L-M
( 0 R ) = K ( 0 R11 R12 R13 )
M-K ( 0 0 R22 R23 )
K+L-M ( 0 0 0 R33 )

where

C = diag( ALPHA(K+1), ... , ALPHA(M) ),
S = diag( BETA(K+1), ... , BETA(M) ),
C**2 + S**2 = I.

(R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
( 0 R22 R23 )
in B(M-K+1:L,N+M-K-L+1:N) on exit.

The routine computes C, S, R, and optionally the unitary
transformation matrices U, V and Q.

In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
A and B implicitly gives the SVD of A*inv(B):
A*inv(B) = U*(D1*inv(D2))*V'.
If ( A',B')' has orthnormal columns, then the GSVD of A and B is also
equal to the CS decomposition of A and B. Furthermore, the GSVD can
be used to derive the solution of the eigenvalue problem:
A'*A x = lambda* B'*B x.
In some literature, the GSVD of A and B is presented in the form
U'*A*X = ( 0 D1 ), V'*B*X = ( 0 D2 )
where U and V are orthogonal and X is nonsingular, and D1 and D2 are
``diagonal''. The former GSVD form can be converted to the latter
form by taking the nonsingular matrix X as

X = Q*( I 0 )
( 0 inv(R) )

The selection of the LAPACK routine is done during compile-time, 
and is determined by the type of values contained in type `MatrixA`.
The type of values is obtained through the `value_type` meta-function
 `typename value_type<MatrixA>::type`.
The dispatching table below illustrates to which specific routine 
the code path will be generated. 

[table Dispatching of ggsvd
[  [ Value type of MatrixA ] [LAPACK routine] ]
[  [`float`][SGGSVD] ]
[  [`double`][DGGSVD] ]
[  [`complex<float>`][CGGSVD] ]
[  [`complex<double>`][ZGGSVD] ]

]


[heading Definition]
Defined in header [headerref boost/numeric/bindings/lapack/driver/ggsvd.hpp].


[heading Parameters or Requirements on Types]

[variablelist Parameters
    [[MatrixA] [The definition of term 1]]
    [[MatrixB] [The definition of term 2]]
    [[MatrixC] [
    The definition of term 3.

    Definitions may contain paragraphs.
    ]]
]


[heading Complexity]


[heading Example]
``
#include <boost/numeric/bindings/lapack/driver/ggsvd.hpp>
using namespace boost::numeric::bindings;

lapack::ggsvd( x, y, z );

``

this will output

``
[5] 0 1 2 3 4 5
``



[heading Notes]


[heading See Also]

* Originating Fortran source files [@http://www.netlib.org/lapack/single/sggsvd.f sggsvd.f], [@http://www.netlib.org/lapack/double/dggsvd.f dggsvd.f], [@http://www.netlib.org/lapack/complex/cggsvd.f cggsvd.f], and [@http://www.netlib.org/lapack/complex16/zggsvd.f zggsvd.f] at Netlib.

[endsect]
